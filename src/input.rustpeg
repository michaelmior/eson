use std::collections::HashMap;
use std::str;

use super::model::{Field, Table};

space
  = [ \t\r\n]+

identifier -> String
  = id:$(([A-z] / "_")+) { id.to_string() }

identifiers -> Vec<String>
  = identifier ++ (space? "," space?)

table -> String
  = table:identifier { table }

field_define -> Field
  = key:"*"? name:identifier {
      let is_key = match key { Some(_) => true, None => false };

      Field { name: name.parse().unwrap(), key: is_key }
    }

field_defines -> Vec<Field>
  = field_define ++ (space? "," space?)

create -> Table
  = table:table space?
    "(" space? fields:field_defines space? ")" {
      let mut field_map = HashMap::new();
      for field in fields {
        field_map.insert(field.name.clone(), field);
      }

      Table {
        name: table.parse().unwrap(),
        fields: field_map,
        ..Default::default()
      }
    }

func_dep -> (String, Vec<String>, Vec<String>)
  = "FD" space table:identifier space lhs:identifiers space "->"
    space rhs:identifiers { (table, lhs, rhs) }

inc_dep -> (String, Vec<String>, String, Vec<String>)
  = "IND" space left_table:identifier space left_fields:identifiers
    space "<=" space
    right_table:identifier space right_fields:identifiers {
      (left_table, left_fields, right_table, right_fields)
    }

pub input -> (Vec<Table>, Vec<(String, Vec<String>, Vec<String>)>,
          Vec<(String, Vec<String>, String, Vec<String>)>)
  = tables:(create ++ "\n") "\n"*
    func_deps:(func_dep ** "\n") "\n"*
    inc_deps:(inc_dep ** "\n") "\n"* {
      (tables, func_deps, inc_deps)
    }
