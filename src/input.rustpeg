use std::collections::HashMap;
use std::str;

use super::model::{Define, Field, Literal, Table, TableOption};

type -> String
  = ("float" / "int" / "text" / "timestamp" / "timeuuid" / "uuid") { match_str.to_string() }

space
  = [ \t\r\n]+

integer -> i64
  = [0-9]+ { match_str.parse().unwrap() }

float -> f64
  = integer "." integer { match_str.parse().unwrap() }

quote
  = "\""

nonquote -> String
  = [^"] { match_str.to_string() }

string -> String
  = quote constant:nonquote quote { constant }

primitive -> Literal
  = integer:integer { Literal::Int(integer) }
  / float:float { Literal::Float(float) }
  / string:string { Literal::Str(string) }

json_pair -> (String, Literal)
  = key:string space? ":" space? value:primitive { (key, value) }

json -> Literal
  = "{" space? pairs:(json_pair ** (space? "," space?)) space? "}" {
      let mut json = HashMap::new();
      for pair in pairs.into_iter() {
        let (key, value) = pair;
        json.insert(key, value);
      }

      Literal::Json(json)
    }

literal -> Literal
  = primitive / json

identifier -> String
  = ([A-z] / "_")+ { match_str.to_string() }

identifiers -> Vec<String>
  = identifier ++ (space? "," space?)

table -> String
  = table:identifier { table }

field_define -> Field
  = name:identifier space field_type:type key:(space "PRIMARY KEY")? {
      let is_key = match key { Some(_) => true, None => false };

      Field { name: name, field_type: field_type, key: is_key }
    }

primary_key -> Vec<String>
  = "PRIMARY KEY" space? "(" space? keys:identifiers space? ")" {
      keys
    }

define -> Vec<Define>
  = field:field_define { vec![Define::Field(field)] } / keys:primary_key {
      keys.iter().map(|k|
        Define::Key(k.to_owned())
      ).collect()
    }

nested_defines -> Vec<Vec<Define>>
  = define ++ (space? "," space?)

defines -> Vec<Field>
  = nested_defines:nested_defines {
      let mut all_defines = Vec::new();
      let mut keys = Vec::new();
      for defines in nested_defines {
        for define in defines {
          match define {
            Define::Field(field) => { all_defines.push(field); },
            Define::Key(key) => { keys.push(key); }
          }
        }
      }

      // Set the key value on necessary fields
      for define in all_defines.iter_mut() {
        if keys.contains(&define.name) {
          define.key = true;
        }
      }

      all_defines
    }

order -> bool
  = "ASC" { true } / "DESC" { false }

field_order -> (String, bool)
  = field:identifier space order:order { (field.to_string(), order) }

field_orders -> Vec<(String, bool)>
  = field_order ++ (space? "," space?)

clustering_order -> Vec<(String, bool)>
  = "CLUSTERING ORDER BY" space?
    "(" space? field_orders:field_orders space? ")" { field_orders }

parameter -> (String, Literal)
  = name:identifier space? "=" space? value:literal { (name, value) }

option -> TableOption
  = parameter:parameter { TableOption::Parameter(parameter) }
  / clustering_order:clustering_order { TableOption::Order(clustering_order) }

options -> Vec<TableOption>
  = option ** (space "AND" space)

create -> Table
  = "CREATE" space ("TABLE" / "COLUMNFAMILY") space table:table space?
    "(" space? fields:defines space? ")"
    options:(space "WITH" space options)? ";"? {
      let mut field_map = HashMap::new();
      for field in fields.into_iter() {
        field_map.insert(field.name.clone(), field);
      }

      Table { name: table, fields: field_map, ..Default::default() }
    }

func_dep -> (String, Vec<String>, Vec<String>)
  = "FD" space table:identifier space lhs:identifiers space "->"
    space rhs:identifiers { (table, lhs, rhs) }

inc_dep -> (String, Vec<String>, String, Vec<String>)
  = "IND" space left_table:identifier space left_fields:identifiers
    space "<=" space
    right_table:identifier space right_fields:identifiers {
      (left_table, left_fields, right_table, right_fields)
    }

#[pub]
input -> (Vec<Table>, Vec<(String, Vec<String>, Vec<String>)>,
          Vec<(String, Vec<String>, String, Vec<String>)>)
  = tables:(create ++ "\n") "\n"*
    func_deps:(func_dep ** "\n") "\n"*
    inc_deps:(inc_dep ** "\n") "\n"* {
      (tables, func_deps, inc_deps)
    }
