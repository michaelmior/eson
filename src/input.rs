// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use std::collections::HashMap;
use std::str;
use super::model::{Define, Field, Literal, Table, TableOption};
use self::RuleResult::{Matched, Failed};
fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos = pos + c.len_utf8();
    (*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T> { Matched(usize, T), Failed, }
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter)
     -> ::std::result::Result<(), ::std::fmt::Error> {
        try!(write ! (
             fmt , "error at {}:{}: expected " , self . line , self . column
             ));
        if self.expected.len() == 0 {
            try!(write ! ( fmt , "EOF" ));
        } else if self.expected.len() == 1 {
            try!(write ! (
                 fmt , "`{}`" , escape_default (
                 self . expected . iter (  ) . next (  ) . unwrap (  ) ) ));
        } else {
            let mut iter = self.expected.iter();
            try!(write ! (
                 fmt , "one of `{}`" , escape_default (
                 iter . next (  ) . unwrap (  ) ) ));
            for elem in iter {
                try!(write ! ( fmt , ", `{}`" , escape_default ( elem ) ));
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ParseError {
    fn description(&self) -> &str { "parse error" }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: usize, m: &'static str)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn slice_eq_case_insensitive(input: &str, state: &mut ParseState, pos: usize,
                             m: &'static str) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(|x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() ||
               input_char_result.unwrap() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char(input: &str, state: &mut ParseState, pos: usize)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let mut remaining = pos;
    let mut lineno: usize = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
struct ParseState<'input> {
    max_err_pos: usize,
    expected: ::std::collections::HashSet<&'static str>,
    _phantom: ::std::marker::PhantomData<&'input ()>,
}
impl <'input> ParseState<'input> {
    fn new() -> ParseState<'input> {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),
                   _phantom: ::std::marker::PhantomData,}
    }
    fn mark_failure(&mut self, pos: usize, expected: &'static str)
     -> RuleResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn parse_type<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res = slice_eq(input, state, pos, "float");
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res =
                                slice_eq(input, state, pos, "int");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "text");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed => {
                                            let choice_res =
                                                slice_eq(input, state, pos,
                                                         "timestamp");
                                            match choice_res {
                                                Matched(pos, value) =>
                                                Matched(pos, value),
                                                Failed => {
                                                    let choice_res =
                                                        slice_eq(input, state,
                                                                 pos,
                                                                 "timeuuid");
                                                    match choice_res {
                                                        Matched(pos, value) =>
                                                        Matched(pos, value),
                                                        Failed =>
                                                        slice_eq(input, state,
                                                                 pos, "uuid"),
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { match_str.to_string() })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_space<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<()> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let step_res =
                if input.len() > pos {
                    let (ch, next) = char_range_at(input, pos);
                    match ch {
                        ' ' | '\t' | '\r' | '\n' => Matched(next, ()),
                        _ => state.mark_failure(pos, "[ \t\r\n]"),
                    }
                } else { state.mark_failure(pos, "[ \t\r\n]") };
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        if repeat_value.len() >= 1usize {
            Matched(repeat_pos, ())
        } else { Failed }
    }
}
fn parse_integer<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<i64> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            if input.len() > pos {
                                let (ch, next) = char_range_at(input, pos);
                                match ch {
                                    '0' ...'9' => Matched(next, ()),
                                    _ => state.mark_failure(pos, "[0-9]"),
                                }
                            } else { state.mark_failure(pos, "[0-9]") };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1usize {
                        Matched(repeat_pos, ())
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { match_str.parse().unwrap() })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_float<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<f64> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_integer(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = slice_eq(input, state, pos, ".");
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_integer(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            match_str.parse().unwrap()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_quote<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<()> {
    slice_eq(input, state, pos, "\"")
}
fn parse_nonquote<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                if input.len() > pos {
                    let (ch, next) = char_range_at(input, pos);
                    match ch {
                        '\"' => state.mark_failure(pos, "[^\"]"),
                        _ => Matched(next, ()),
                    }
                } else { state.mark_failure(pos, "[^\"]") };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { match_str.to_string() })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_string<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_quote(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_nonquote(input, state, pos);
                        match seq_res {
                            Matched(pos, constant) => {
                                {
                                    let seq_res =
                                        parse_quote(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos, { constant })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_primitive<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<Literal> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_integer(input, state, pos);
                    match seq_res {
                        Matched(pos, integer) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Literal::Int(integer) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_float(input, state, pos);
                            match seq_res {
                                Matched(pos, float) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos,
                                                { Literal::Float(float) })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let start_pos = pos;
                        {
                            let seq_res = parse_string(input, state, pos);
                            match seq_res {
                                Matched(pos, string) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos, { Literal::Str(string) })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_json_pair<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<(String, Literal)> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_string(input, state, pos);
            match seq_res {
                Matched(pos, key) => {
                    {
                        let seq_res =
                            match parse_space(input, state, pos) {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, ":");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    match parse_space(input,
                                                                      state,
                                                                      pos) {
                                                        Matched(newpos, value)
                                                        => {
                                                            Matched(newpos,
                                                                    Some(value))
                                                        }
                                                        Failed => {
                                                            Matched(pos, None)
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_primitive(input,
                                                                                state,
                                                                                pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        value)
                                                                => {
                                                                    {
                                                                        let match_str =
                                                                            &input[start_pos..pos];
                                                                        Matched(pos,
                                                                                {
                                                                                    (key,
                                                                                     value)
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_json<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<Literal> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "{");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            match parse_space(input, state, pos) {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let pos =
                                                    if repeat_value.len() > 0
                                                       {
                                                        let sep_res =
                                                            {
                                                                let seq_res =
                                                                    match parse_space(input,
                                                                                      state,
                                                                                      pos)
                                                                        {
                                                                        Matched(newpos,
                                                                                value)
                                                                        => {
                                                                            Matched(newpos,
                                                                                    Some(value))
                                                                        }
                                                                        Failed
                                                                        => {
                                                                            Matched(pos,
                                                                                    None)
                                                                        }
                                                                    };
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let seq_res =
                                                                                slice_eq(input,
                                                                                         state,
                                                                                         pos,
                                                                                         ",");
                                                                            match seq_res
                                                                                {
                                                                                Matched(pos,
                                                                                        _)
                                                                                =>
                                                                                {
                                                                                    match parse_space(input,
                                                                                                      state,
                                                                                                      pos)
                                                                                        {
                                                                                        Matched(newpos,
                                                                                                value)
                                                                                        =>
                                                                                        {
                                                                                            Matched(newpos,
                                                                                                    Some(value))
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        {
                                                                                            Matched(pos,
                                                                                                    None)
                                                                                        }
                                                                                    }
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                Failed,
                                                                            }
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            };
                                                        match sep_res {
                                                            Matched(newpos, _)
                                                            => {
                                                                newpos
                                                            }
                                                            Failed => break ,
                                                        }
                                                    } else { pos };
                                                let step_res =
                                                    parse_json_pair(input,
                                                                    state,
                                                                    pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, repeat_value)
                                        };
                                    match seq_res {
                                        Matched(pos, pairs) => {
                                            {
                                                let seq_res =
                                                    match parse_space(input,
                                                                      state,
                                                                      pos) {
                                                        Matched(newpos, value)
                                                        => {
                                                            Matched(newpos,
                                                                    Some(value))
                                                        }
                                                        Failed => {
                                                            Matched(pos, None)
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "}");
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let match_str =
                                                                            &input[start_pos..pos];
                                                                        Matched(pos,
                                                                                {
                                                                                    let mut json =
                                                                                        HashMap::new();
                                                                                    for pair
                                                                                        in
                                                                                        pairs.into_iter()
                                                                                        {
                                                                                        let (key,
                                                                                             value) =
                                                                                            pair;
                                                                                        json.insert(key,
                                                                                                    value);
                                                                                    }
                                                                                    Literal::Json(json)
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_literal<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Literal> {
    {
        let choice_res = parse_primitive(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_json(input, state, pos),
        }
    }
}
fn parse_identifier<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let choice_res =
                                    if input.len() > pos {
                                        let (ch, next) =
                                            char_range_at(input, pos);
                                        match ch {
                                            'A' ...'z' => Matched(next, ()),
                                            _ =>
                                            state.mark_failure(pos, "[A-z]"),
                                        }
                                    } else {
                                        state.mark_failure(pos, "[A-z]")
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "_"),
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1usize {
                        Matched(repeat_pos, ())
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { match_str.to_string() })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_identifiers<'input>(input: &'input str,
                             state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Vec<String>> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let pos =
                if repeat_value.len() > 0 {
                    let sep_res =
                        {
                            let seq_res =
                                match parse_space(input, state, pos) {
                                    Matched(newpos, value) => {
                                        Matched(newpos, Some(value))
                                    }
                                    Failed => { Matched(pos, None) }
                                };
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            slice_eq(input, state, pos, ",");
                                        match seq_res {
                                            Matched(pos, _) => {
                                                match parse_space(input,
                                                                  state, pos)
                                                    {
                                                    Matched(newpos, value) =>
                                                    {
                                                        Matched(newpos,
                                                                Some(value))
                                                    }
                                                    Failed => {
                                                        Matched(pos, None)
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                    match sep_res {
                        Matched(newpos, _) => { newpos }
                        Failed => break ,
                    }
                } else { pos };
            let step_res = parse_identifier(input, state, pos);
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        if repeat_value.len() >= 1usize {
            Matched(repeat_pos, repeat_value)
        } else { Failed }
    }
}
fn parse_table<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_identifier(input, state, pos);
            match seq_res {
                Matched(pos, table) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { table })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_field_define<'input>(input: &'input str,
                              state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Field> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_identifier(input, state, pos);
            match seq_res {
                Matched(pos, name) => {
                    {
                        let seq_res = parse_space(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_type(input, state, pos);
                                    match seq_res {
                                        Matched(pos, field_type) => {
                                            {
                                                let seq_res =
                                                    match {
                                                              let seq_res =
                                                                  parse_space(input,
                                                                              state,
                                                                              pos);
                                                              match seq_res {
                                                                  Matched(pos,
                                                                          _)
                                                                  => {
                                                                      slice_eq(input,
                                                                               state,
                                                                               pos,
                                                                               "PRIMARY KEY")
                                                                  }
                                                                  Failed =>
                                                                  Failed,
                                                              }
                                                          } {
                                                        Matched(newpos, value)
                                                        => {
                                                            Matched(newpos,
                                                                    Some(value))
                                                        }
                                                        Failed => {
                                                            Matched(pos, None)
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, key) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    {
                                                                        let is_key =
                                                                            match key
                                                                                {
                                                                                Some(_)
                                                                                =>
                                                                                true,
                                                                                None
                                                                                =>
                                                                                false,
                                                                            };
                                                                        Field{name:
                                                                                  name,
                                                                              field_type:
                                                                                  field_type,
                                                                              key:
                                                                                  is_key,}
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_primary_key<'input>(input: &'input str,
                             state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Vec<String>> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "PRIMARY KEY");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            match parse_space(input, state, pos) {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "(");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    match parse_space(input,
                                                                      state,
                                                                      pos) {
                                                        Matched(newpos, value)
                                                        => {
                                                            Matched(newpos,
                                                                    Some(value))
                                                        }
                                                        Failed => {
                                                            Matched(pos, None)
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_identifiers(input,
                                                                                  state,
                                                                                  pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        keys)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            match parse_space(input,
                                                                                              state,
                                                                                              pos)
                                                                                {
                                                                                Matched(newpos,
                                                                                        value)
                                                                                =>
                                                                                {
                                                                                    Matched(newpos,
                                                                                            Some(value))
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    Matched(pos,
                                                                                            None)
                                                                                }
                                                                            };
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        slice_eq(input,
                                                                                                 state,
                                                                                                 pos,
                                                                                                 ")");
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    &input[start_pos..pos];
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            keys
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_define<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<Vec<Define>> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_field_define(input, state, pos);
                    match seq_res {
                        Matched(pos, field) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos,
                                        { vec!(Define:: Field ( field )) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_primary_key(input, state, pos);
                    match seq_res {
                        Matched(pos, keys) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos,
                                        {
                                            keys.iter().map(|k|
                                                                Define::Key(k.to_owned())).collect()
                                        })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_nested_defines<'input>(input: &'input str,
                                state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Vec<Vec<Define>>> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let pos =
                if repeat_value.len() > 0 {
                    let sep_res =
                        {
                            let seq_res =
                                match parse_space(input, state, pos) {
                                    Matched(newpos, value) => {
                                        Matched(newpos, Some(value))
                                    }
                                    Failed => { Matched(pos, None) }
                                };
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            slice_eq(input, state, pos, ",");
                                        match seq_res {
                                            Matched(pos, _) => {
                                                match parse_space(input,
                                                                  state, pos)
                                                    {
                                                    Matched(newpos, value) =>
                                                    {
                                                        Matched(newpos,
                                                                Some(value))
                                                    }
                                                    Failed => {
                                                        Matched(pos, None)
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                    match sep_res {
                        Matched(newpos, _) => { newpos }
                        Failed => break ,
                    }
                } else { pos };
            let step_res = parse_define(input, state, pos);
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        if repeat_value.len() >= 1usize {
            Matched(repeat_pos, repeat_value)
        } else { Failed }
    }
}
fn parse_defines<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Vec<Field>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_nested_defines(input, state, pos);
            match seq_res {
                Matched(pos, nested_defines) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos,
                                {
                                    let mut all_defines = Vec::new();
                                    let mut keys = Vec::new();
                                    for defines in nested_defines {
                                        for define in defines {
                                            match define {
                                                Define::Field(field) => {
                                                    all_defines.push(field);
                                                }
                                                Define::Key(key) => {
                                                    keys.push(key);
                                                }
                                            }
                                        }
                                    }
                                    for define in all_defines.iter_mut() {
                                        if keys.contains(&define.name) {
                                            define.key = true;
                                        }
                                    }
                                    all_defines
                                })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_order<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<bool> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "ASC");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { true })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "DESC");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { false })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_field_order<'input>(input: &'input str,
                             state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<(String, bool)> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_identifier(input, state, pos);
            match seq_res {
                Matched(pos, field) => {
                    {
                        let seq_res = parse_space(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_order(input, state, pos);
                                    match seq_res {
                                        Matched(pos, order) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            (field.to_string(),
                                                             order)
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_field_orders<'input>(input: &'input str,
                              state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Vec<(String, bool)>> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let pos =
                if repeat_value.len() > 0 {
                    let sep_res =
                        {
                            let seq_res =
                                match parse_space(input, state, pos) {
                                    Matched(newpos, value) => {
                                        Matched(newpos, Some(value))
                                    }
                                    Failed => { Matched(pos, None) }
                                };
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            slice_eq(input, state, pos, ",");
                                        match seq_res {
                                            Matched(pos, _) => {
                                                match parse_space(input,
                                                                  state, pos)
                                                    {
                                                    Matched(newpos, value) =>
                                                    {
                                                        Matched(newpos,
                                                                Some(value))
                                                    }
                                                    Failed => {
                                                        Matched(pos, None)
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                    match sep_res {
                        Matched(newpos, _) => { newpos }
                        Failed => break ,
                    }
                } else { pos };
            let step_res = parse_field_order(input, state, pos);
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        if repeat_value.len() >= 1usize {
            Matched(repeat_pos, repeat_value)
        } else { Failed }
    }
}
fn parse_clustering_order<'input>(input: &'input str,
                                  state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Vec<(String, bool)>> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "CLUSTERING ORDER BY");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            match parse_space(input, state, pos) {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "(");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    match parse_space(input,
                                                                      state,
                                                                      pos) {
                                                        Matched(newpos, value)
                                                        => {
                                                            Matched(newpos,
                                                                    Some(value))
                                                        }
                                                        Failed => {
                                                            Matched(pos, None)
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_field_orders(input,
                                                                                   state,
                                                                                   pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        field_orders)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            match parse_space(input,
                                                                                              state,
                                                                                              pos)
                                                                                {
                                                                                Matched(newpos,
                                                                                        value)
                                                                                =>
                                                                                {
                                                                                    Matched(newpos,
                                                                                            Some(value))
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    Matched(pos,
                                                                                            None)
                                                                                }
                                                                            };
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        slice_eq(input,
                                                                                                 state,
                                                                                                 pos,
                                                                                                 ")");
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    &input[start_pos..pos];
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            field_orders
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_parameter<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<(String, Literal)> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_identifier(input, state, pos);
            match seq_res {
                Matched(pos, name) => {
                    {
                        let seq_res =
                            match parse_space(input, state, pos) {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "=");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    match parse_space(input,
                                                                      state,
                                                                      pos) {
                                                        Matched(newpos, value)
                                                        => {
                                                            Matched(newpos,
                                                                    Some(value))
                                                        }
                                                        Failed => {
                                                            Matched(pos, None)
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_literal(input,
                                                                              state,
                                                                              pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        value)
                                                                => {
                                                                    {
                                                                        let match_str =
                                                                            &input[start_pos..pos];
                                                                        Matched(pos,
                                                                                {
                                                                                    (name,
                                                                                     value)
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_option<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<TableOption> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_parameter(input, state, pos);
                    match seq_res {
                        Matched(pos, parameter) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos,
                                        { TableOption::Parameter(parameter) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_clustering_order(input, state, pos);
                    match seq_res {
                        Matched(pos, clustering_order) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos,
                                        {
                                            TableOption::Order(clustering_order)
                                        })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_options<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Vec<TableOption>> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let pos =
                if repeat_value.len() > 0 {
                    let sep_res =
                        {
                            let seq_res = parse_space(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            slice_eq(input, state, pos,
                                                     "AND");
                                        match seq_res {
                                            Matched(pos, _) => {
                                                parse_space(input, state, pos)
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                    match sep_res {
                        Matched(newpos, _) => { newpos }
                        Failed => break ,
                    }
                } else { pos };
            let step_res = parse_option(input, state, pos);
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, repeat_value)
    }
}
fn parse_create<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<Table> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "CREATE");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_space(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let choice_res =
                                                slice_eq(input, state, pos,
                                                         "TABLE");
                                            match choice_res {
                                                Matched(pos, value) =>
                                                Matched(pos, value),
                                                Failed =>
                                                slice_eq(input, state, pos,
                                                         "COLUMNFAMILY"),
                                            }
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_space(input, state,
                                                                pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_table(input,
                                                                            state,
                                                                            pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        table)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            match parse_space(input,
                                                                                              state,
                                                                                              pos)
                                                                                {
                                                                                Matched(newpos,
                                                                                        value)
                                                                                =>
                                                                                {
                                                                                    Matched(newpos,
                                                                                            Some(value))
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    Matched(pos,
                                                                                            None)
                                                                                }
                                                                            };
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        slice_eq(input,
                                                                                                 state,
                                                                                                 pos,
                                                                                                 "(");
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    match parse_space(input,
                                                                                                                      state,
                                                                                                                      pos)
                                                                                                        {
                                                                                                        Matched(newpos,
                                                                                                                value)
                                                                                                        =>
                                                                                                        {
                                                                                                            Matched(newpos,
                                                                                                                    Some(value))
                                                                                                        }
                                                                                                        Failed
                                                                                                        =>
                                                                                                        {
                                                                                                            Matched(pos,
                                                                                                                    None)
                                                                                                        }
                                                                                                    };
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let seq_res =
                                                                                                                parse_defines(input,
                                                                                                                              state,
                                                                                                                              pos);
                                                                                                            match seq_res
                                                                                                                {
                                                                                                                Matched(pos,
                                                                                                                        fields)
                                                                                                                =>
                                                                                                                {
                                                                                                                    {
                                                                                                                        let seq_res =
                                                                                                                            match parse_space(input,
                                                                                                                                              state,
                                                                                                                                              pos)
                                                                                                                                {
                                                                                                                                Matched(newpos,
                                                                                                                                        value)
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    Matched(newpos,
                                                                                                                                            Some(value))
                                                                                                                                }
                                                                                                                                Failed
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    Matched(pos,
                                                                                                                                            None)
                                                                                                                                }
                                                                                                                            };
                                                                                                                        match seq_res
                                                                                                                            {
                                                                                                                            Matched(pos,
                                                                                                                                    _)
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                {
                                                                                                                                    let seq_res =
                                                                                                                                        slice_eq(input,
                                                                                                                                                 state,
                                                                                                                                                 pos,
                                                                                                                                                 ")");
                                                                                                                                    match seq_res
                                                                                                                                        {
                                                                                                                                        Matched(pos,
                                                                                                                                                _)
                                                                                                                                        =>
                                                                                                                                        {
                                                                                                                                            {
                                                                                                                                                let seq_res =
                                                                                                                                                    match {
                                                                                                                                                              let seq_res =
                                                                                                                                                                  parse_space(input,
                                                                                                                                                                              state,
                                                                                                                                                                              pos);
                                                                                                                                                              match seq_res
                                                                                                                                                                  {
                                                                                                                                                                  Matched(pos,
                                                                                                                                                                          _)
                                                                                                                                                                  =>
                                                                                                                                                                  {
                                                                                                                                                                      {
                                                                                                                                                                          let seq_res =
                                                                                                                                                                              slice_eq(input,
                                                                                                                                                                                       state,
                                                                                                                                                                                       pos,
                                                                                                                                                                                       "WITH");
                                                                                                                                                                          match seq_res
                                                                                                                                                                              {
                                                                                                                                                                              Matched(pos,
                                                                                                                                                                                      _)
                                                                                                                                                                              =>
                                                                                                                                                                              {
                                                                                                                                                                                  {
                                                                                                                                                                                      let seq_res =
                                                                                                                                                                                          parse_space(input,
                                                                                                                                                                                                      state,
                                                                                                                                                                                                      pos);
                                                                                                                                                                                      match seq_res
                                                                                                                                                                                          {
                                                                                                                                                                                          Matched(pos,
                                                                                                                                                                                                  _)
                                                                                                                                                                                          =>
                                                                                                                                                                                          {
                                                                                                                                                                                              parse_options(input,
                                                                                                                                                                                                            state,
                                                                                                                                                                                                            pos)
                                                                                                                                                                                          }
                                                                                                                                                                                          Failed
                                                                                                                                                                                          =>
                                                                                                                                                                                          Failed,
                                                                                                                                                                                      }
                                                                                                                                                                                  }
                                                                                                                                                                              }
                                                                                                                                                                              Failed
                                                                                                                                                                              =>
                                                                                                                                                                              Failed,
                                                                                                                                                                          }
                                                                                                                                                                      }
                                                                                                                                                                  }
                                                                                                                                                                  Failed
                                                                                                                                                                  =>
                                                                                                                                                                  Failed,
                                                                                                                                                              }
                                                                                                                                                          }
                                                                                                                                                        {
                                                                                                                                                        Matched(newpos,
                                                                                                                                                                value)
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            Matched(newpos,
                                                                                                                                                                    Some(value))
                                                                                                                                                        }
                                                                                                                                                        Failed
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            Matched(pos,
                                                                                                                                                                    None)
                                                                                                                                                        }
                                                                                                                                                    };
                                                                                                                                                match seq_res
                                                                                                                                                    {
                                                                                                                                                    Matched(pos,
                                                                                                                                                            options)
                                                                                                                                                    =>
                                                                                                                                                    {
                                                                                                                                                        {
                                                                                                                                                            let seq_res =
                                                                                                                                                                match slice_eq(input,
                                                                                                                                                                               state,
                                                                                                                                                                               pos,
                                                                                                                                                                               ";")
                                                                                                                                                                    {
                                                                                                                                                                    Matched(newpos,
                                                                                                                                                                            value)
                                                                                                                                                                    =>
                                                                                                                                                                    {
                                                                                                                                                                        Matched(newpos,
                                                                                                                                                                                Some(value))
                                                                                                                                                                    }
                                                                                                                                                                    Failed
                                                                                                                                                                    =>
                                                                                                                                                                    {
                                                                                                                                                                        Matched(pos,
                                                                                                                                                                                None)
                                                                                                                                                                    }
                                                                                                                                                                };
                                                                                                                                                            match seq_res
                                                                                                                                                                {
                                                                                                                                                                Matched(pos,
                                                                                                                                                                        _)
                                                                                                                                                                =>
                                                                                                                                                                {
                                                                                                                                                                    {
                                                                                                                                                                        let match_str =
                                                                                                                                                                            &input[start_pos..pos];
                                                                                                                                                                        Matched(pos,
                                                                                                                                                                                {
                                                                                                                                                                                    let mut field_map =
                                                                                                                                                                                        HashMap::new();
                                                                                                                                                                                    for field
                                                                                                                                                                                        in
                                                                                                                                                                                        fields.into_iter()
                                                                                                                                                                                        {
                                                                                                                                                                                        field_map.insert(field.name.clone(),
                                                                                                                                                                                                         field);
                                                                                                                                                                                    }
                                                                                                                                                                                    Table{name:
                                                                                                                                                                                              table,
                                                                                                                                                                                          fields:
                                                                                                                                                                                              field_map,}
                                                                                                                                                                                })
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                                Failed
                                                                                                                                                                =>
                                                                                                                                                                Failed,
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                    Failed
                                                                                                                                                    =>
                                                                                                                                                    Failed,
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                        Failed
                                                                                                                                        =>
                                                                                                                                        Failed,
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                            Failed
                                                                                                                            =>
                                                                                                                            Failed,
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                                Failed
                                                                                                                =>
                                                                                                                Failed,
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_func_dep<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize)
 -> RuleResult<(String, Vec<String>, Vec<String>)> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "FD");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_space(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_identifier(input, state, pos);
                                    match seq_res {
                                        Matched(pos, table) => {
                                            {
                                                let seq_res =
                                                    parse_space(input, state,
                                                                pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_identifiers(input,
                                                                                  state,
                                                                                  pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        lhs)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse_space(input,
                                                                                        state,
                                                                                        pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        slice_eq(input,
                                                                                                 state,
                                                                                                 pos,
                                                                                                 "->");
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse_space(input,
                                                                                                                state,
                                                                                                                pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let seq_res =
                                                                                                                parse_identifiers(input,
                                                                                                                                  state,
                                                                                                                                  pos);
                                                                                                            match seq_res
                                                                                                                {
                                                                                                                Matched(pos,
                                                                                                                        rhs)
                                                                                                                =>
                                                                                                                {
                                                                                                                    {
                                                                                                                        let match_str =
                                                                                                                            &input[start_pos..pos];
                                                                                                                        Matched(pos,
                                                                                                                                {
                                                                                                                                    (table,
                                                                                                                                     lhs,
                                                                                                                                     rhs)
                                                                                                                                })
                                                                                                                    }
                                                                                                                }
                                                                                                                Failed
                                                                                                                =>
                                                                                                                Failed,
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_inc_dep<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize)
 -> RuleResult<(String, Vec<String>, String, Vec<String>)> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "IND");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_space(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_identifier(input, state, pos);
                                    match seq_res {
                                        Matched(pos, left_table) => {
                                            {
                                                let seq_res =
                                                    parse_space(input, state,
                                                                pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_identifiers(input,
                                                                                  state,
                                                                                  pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        left_fields)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse_space(input,
                                                                                        state,
                                                                                        pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        slice_eq(input,
                                                                                                 state,
                                                                                                 pos,
                                                                                                 "<=");
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse_space(input,
                                                                                                                state,
                                                                                                                pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let seq_res =
                                                                                                                parse_identifier(input,
                                                                                                                                 state,
                                                                                                                                 pos);
                                                                                                            match seq_res
                                                                                                                {
                                                                                                                Matched(pos,
                                                                                                                        right_table)
                                                                                                                =>
                                                                                                                {
                                                                                                                    {
                                                                                                                        let seq_res =
                                                                                                                            parse_space(input,
                                                                                                                                        state,
                                                                                                                                        pos);
                                                                                                                        match seq_res
                                                                                                                            {
                                                                                                                            Matched(pos,
                                                                                                                                    _)
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                {
                                                                                                                                    let seq_res =
                                                                                                                                        parse_identifiers(input,
                                                                                                                                                          state,
                                                                                                                                                          pos);
                                                                                                                                    match seq_res
                                                                                                                                        {
                                                                                                                                        Matched(pos,
                                                                                                                                                right_fields)
                                                                                                                                        =>
                                                                                                                                        {
                                                                                                                                            {
                                                                                                                                                let match_str =
                                                                                                                                                    &input[start_pos..pos];
                                                                                                                                                Matched(pos,
                                                                                                                                                        {
                                                                                                                                                            (left_table,
                                                                                                                                                             left_fields,
                                                                                                                                                             right_table,
                                                                                                                                                             right_fields)
                                                                                                                                                        })
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                        Failed
                                                                                                                                        =>
                                                                                                                                        Failed,
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                            Failed
                                                                                                                            =>
                                                                                                                            Failed,
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                                Failed
                                                                                                                =>
                                                                                                                Failed,
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_input<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize)
 ->
     RuleResult<(Vec<Table>, Vec<(String, Vec<String>, Vec<String>)>,
                 Vec<(String, Vec<String>, String, Vec<String>)>)> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let pos =
                            if repeat_value.len() > 0 {
                                let sep_res =
                                    slice_eq(input, state, pos, "\n");
                                match sep_res {
                                    Matched(newpos, _) => { newpos }
                                    Failed => break ,
                                }
                            } else { pos };
                        let step_res = parse_create(input, state, pos);
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1usize {
                        Matched(repeat_pos, repeat_value)
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, tables) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        slice_eq(input, state, pos, "\n");
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let pos =
                                                    if repeat_value.len() > 0
                                                       {
                                                        let sep_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "\n");
                                                        match sep_res {
                                                            Matched(newpos, _)
                                                            => {
                                                                newpos
                                                            }
                                                            Failed => break ,
                                                        }
                                                    } else { pos };
                                                let step_res =
                                                    parse_func_dep(input,
                                                                   state,
                                                                   pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, repeat_value)
                                        };
                                    match seq_res {
                                        Matched(pos, func_deps) => {
                                            {
                                                let seq_res =
                                                    {
                                                        let mut repeat_pos =
                                                            pos;
                                                        loop  {
                                                            let pos =
                                                                repeat_pos;
                                                            let step_res =
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "\n");
                                                            match step_res {
                                                                Matched(newpos,
                                                                        value)
                                                                => {
                                                                    repeat_pos
                                                                        =
                                                                        newpos;
                                                                }
                                                                Failed => {
                                                                    break ;
                                                                }
                                                            }
                                                        }
                                                        Matched(repeat_pos,
                                                                ())
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                {
                                                                    let mut repeat_pos =
                                                                        pos;
                                                                    let mut repeat_value =
                                                                        vec!();
                                                                    loop  {
                                                                        let pos =
                                                                            repeat_pos;
                                                                        let pos =
                                                                            if repeat_value.len()
                                                                                   >
                                                                                   0
                                                                               {
                                                                                let sep_res =
                                                                                    slice_eq(input,
                                                                                             state,
                                                                                             pos,
                                                                                             "\n");
                                                                                match sep_res
                                                                                    {
                                                                                    Matched(newpos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        newpos
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    break
                                                                                        ,
                                                                                }
                                                                            } else {
                                                                                pos
                                                                            };
                                                                        let step_res =
                                                                            parse_inc_dep(input,
                                                                                          state,
                                                                                          pos);
                                                                        match step_res
                                                                            {
                                                                            Matched(newpos,
                                                                                    value)
                                                                            =>
                                                                            {
                                                                                repeat_pos
                                                                                    =
                                                                                    newpos;
                                                                                repeat_value.push(value);
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            {
                                                                                break
                                                                                    ;
                                                                            }
                                                                        }
                                                                    }
                                                                    Matched(repeat_pos,
                                                                            repeat_value)
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        inc_deps)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            {
                                                                                let mut repeat_pos =
                                                                                    pos;
                                                                                loop 
                                                                                     {
                                                                                    let pos =
                                                                                        repeat_pos;
                                                                                    let step_res =
                                                                                        slice_eq(input,
                                                                                                 state,
                                                                                                 pos,
                                                                                                 "\n");
                                                                                    match step_res
                                                                                        {
                                                                                        Matched(newpos,
                                                                                                value)
                                                                                        =>
                                                                                        {
                                                                                            repeat_pos
                                                                                                =
                                                                                                newpos;
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        {
                                                                                            break
                                                                                                ;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                Matched(repeat_pos,
                                                                                        ())
                                                                            };
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        &input[start_pos..pos];
                                                                                    Matched(pos,
                                                                                            {
                                                                                                (tables,
                                                                                                 func_deps,
                                                                                                 inc_deps)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
pub fn input<'input>(input: &'input str)
 ->
     ParseResult<(Vec<Table>, Vec<(String, Vec<String>, Vec<String>)>,
                  Vec<(String, Vec<String>, String, Vec<String>)>)> {
    let mut state = ParseState::new();
    match parse_input(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
